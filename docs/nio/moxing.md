---
title: 一文彻底理解Java IO模型(阻塞IO非阻塞IO/IO多路复用)
shortTitle: 一文彻底理解Java IO模型
category:
  - Java核心
tag:
  - Java NIO
description: Java程序员进阶之路，小白的零基础Java教程，一文彻底理解 Java IO 模型(非阻塞 IO/IO多路复用/异步IO)
head:
  - - meta
    - name: keywords
      content: Java,Java SE,Java基础,Java教程,Java程序员进阶之路,Java进阶之路,Java入门,教程,nio,多路复用,阻塞IO
---

### 01、IO的五种模型

>如果觉得枯燥可以跳过看 03、04、05 的内容。

网上的资料很多都以 IO 的五种模型（[后面会再细讲](https://tobebetterjavaer.com/nio/moxing.html)）为基础来讲解 NIO，而 IO 这五种模型其中又涉及到了很多概念：`同步/异步/阻塞/非阻塞/多路复用`，**而不同的人又有不同的理解方式**。

I/O 的五种模型如下：

- 阻塞 I/O（Blocking I/O）：在这种模型中，I/O 操作是阻塞的，即执行 I/O 操作时，线程会被阻塞，直到操作完成。在阻塞 I/O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I/O 模型的性能较差。
- 非阻塞 I/O（Non-blocking I/O）：在这种模型中，I/O 操作不会阻塞线程。当数据尚未准备好时，I/O 调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行 I/O 操作。非阻塞 I/O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。
- I/O 多路复用（I/O Multiplexing）：这种模型使用操作系统提供的多路复用功能（如 select、poll、epoll 等），使得单个线程可以同时处理多个 I/O 事件。当某个连接上的数据准备好时，操作系统会通知应用程序。这样，应用程序可以在一个线程中处理多个并发连接，而不需要为每个连接创建一个线程。
- 信号驱动 I/O（Signal-driven I/O）：在这种模型中，应用程序可以向操作系统注册一个信号处理函数，当某个 I/O 事件发生时，操作系统会发送一个信号通知应用程序。应用程序在收到信号后处理相应的 I/O 事件。这种模型与非阻塞 I/O 类似，也需要在应用程序级别进行事件管理和调度。
- 异步 I/O（Asynchronous I/O）：异步 I/O 模型与同步 I/O 模型的主要区别在于，异步 I/O 操作会在后台运行，当操作完成时，操作系统会通知应用程序。应用程序不需要等待 I/O 操作的完成，可以继续执行其他任务。这种模型适用于处理大量并发连接，且可以简化应用程序的设计和开发。

下面解释一下同步/异步概念。

- 同步：在执行 I/O 操作时，应用程序需要等待操作的完成。同步操作会导致线程阻塞，直到操作完成。同步 I/O 包括阻塞 I/O、非阻塞 I/O 和 I/O 多路复用。
- 异步：在执行 I/O 操作时，应用程序不需要等待操作的完成。异步操作允许应用程序在 I/O 操作进行时继续执行其他任务。异步 I/O 模型包括信号驱动 I/O 和异步 I/O。

再来看阻塞/非阻塞的概念。

- 阻塞：在阻塞 I/O 操作中，线程必须等待 I/O 操作完成才能继续执行。在此期间，线程无法执行其他任务。
- 非阻塞：在非阻塞 I/O 操作中，线程无需等待 I/O 操作完成，即使数据尚未准备好。线程可以在等待数据时执行其他任务。

然后是多路复用的概念。

多路复用：多路复用是一种处理多个 I/O 事件的技术。它允许一个线程同时监视多个文件描述符或通道。当某个 I/O 事件准备好时，多路复用机制会通知应用程序，从而实现在单个线程中处理多个并发连接。

假设你现在是个大厨（炖个老母鸡汤，切点土豆丝/姜丝/葱丝）：

- 同步/阻塞：你站在锅边，一直等到汤炖好，期间不能做其他事情，直到汤炖好才去处理其他任务。
- 同步/非阻塞：你不断地查看锅里的汤，看是否炖好。在检查的间隙，你可以处理其他任务，如切菜。但你需要不断地切换任务，确保汤炖好了就可以处理。
- 异步/信号驱动：你给锅安装一个传感器，当汤炖好时，传感器会发出信号提醒你。在此期间，你可以处理其他任务，而不用担心错过汤炖好的时机。
- 异步 I/O：你请了一个助手，让他负责炖汤。当汤炖好时，助手会通知你。你可以专心处理其他任务，而无需关心炖汤的过程。

这下清楚了吧？

### 02、select/epoll/poll/pselect/fd

还有涉及到 Unix 的`select/epoll/poll/pselect/fd`这些关键字，没有相关基础的人看起来简直是天书，这里补充一下。

- select 是 Unix 系统中最早的 I/O 多路复用技术。它允许一个线程同时监视多个文件描述符（如[套接字](https://tobebetterjavaer.com/socket/socket.html)），并等待某个文件描述符上的 I/O 事件（如可读、可写或异常）。select 的主要问题是性能受限，特别是在处理大量文件描述符时。这是因为它使用一个位掩码来表示文件描述符集，每次调用都需要传递这个掩码，并在内核和用户空间之间进行复制。

- poll 是对 select 的改进。它使用一个文件描述符数组而不是位掩码来表示文件描述符集。这样可以避免 select 中的性能问题。然而，poll 仍然需要遍历整个文件描述符数组，以检查每个文件描述符的状态。因此，在处理大量文件描述符时，性能仍然受限。

- epoll 是 Linux 中的一种高性能 I/O 多路复用技术。它通过在内核中维护一个事件表来避免遍历文件描述符数组的性能问题。当某个文件描述符上的 I/O 事件发生时，内核会将该事件添加到事件表中。应用程序可以使用 epoll_wait 函数来获取已准备好的 I/O 事件，而无需遍历整个文件描述符集。这种方法大大提高了在大量并发连接下的性能。

- pselect 是 select 的一个变体，它支持更精确的超时控制和原子性信号处理。pselect 允许应用程序在等待 I/O 事件时阻塞信号，从而避免竞争条件。然而，与 select 相比，pselect 在性能方面没有太大改进。

- fd：这个关键字指的是 "file descriptor"（文件描述符），它是 Unix 系统中用于表示打开的文件、套接字和其他 I/O 对象的整数标识符。文件描述符在 I/O 多路复用中起着关键作用，因为它们允许应用程序同时监视多个 I/O 对象。

**文件的IO就告一段落了**，我们来学习网络中的IO~~~为了更好地理解NIO，**我们先来学习一下IO的模型**~

根据UNIX网络编程对I/O模型的分类，**在UNIX可以归纳成5种I/O模型**：

*   **阻塞I/O**
*   **非阻塞I/O**
*   **I/O多路复用**
*   信号驱动I/O
*   异步I/O

## 学习I/O模型需要的基础

### 文件描述符

Linux 的内核将所有外部设备**都看做一个文件来操作**，对一个文件的读写操作会**调用内核提供的系统命令(api)**，返回一个`file descriptor`（fd，文件描述符）。而对一个socket的读写也会有响应的描述符，称为`socket fd`（socket文件描述符），描述符就是一个数字，**指向内核中的一个结构体**（文件路径，数据区等一些属性）。

*   所以说：在Linux下对文件的操作是**利用文件描述符(file descriptor)来实现的**。

### 用户空间和内核空间

为了保证用户进程不能直接操作内核（kernel），**保证内核的安全**，操心系统将虚拟空间划分为两部分

*   **一部分为内核空间**。
*   **一部分为用户空间**。

### I/O运行过程

我们来看看IO在系统中的运行是怎么样的(我们**以read为例**)



![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nio/moxing-54ee4738-b689-4026-863f-13e456b374de.jpg)



可以发现的是：当应用程序调用read方法时，是需要**等待**的--->从内核空间中找数据，再将内核空间的数据拷贝到用户空间的。

*   **这个等待是必要的过程**！

下面只讲解用得最多的3个I/0模型：

*   **阻塞I/O**
*   **非阻塞I/O**
*   **I/O多路复用**

## 阻塞I/O模型

在进程(用户)空间中调用`recvfrom`，其系统调用直到数据包到达且**被复制到应用进程的缓冲区中或者发生错误时才返回**，在此期间**一直等待**。



![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nio/moxing-8a1cb207-6c56-4bd8-8489-c21d5a76e1ca.jpg)



## 非阻塞I/O模型

`recvfrom`从应用层到内核的时候，如果没有数据就**直接返回**一个EWOULDBLOCK错误，一般都对非阻塞I/O模型**进行轮询检查这个状态**，看内核是不是有数据到来。



![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nio/moxing-6590a3de-0e7c-4ce2-aa1c-815625095e62.jpg)



## I/O复用模型

前面也已经说了：在Linux下对文件的操作是**利用文件描述符(file descriptor)来实现的**。

在Linux下它是这样子实现I/O复用模型的：

*   调用`select/poll/epoll/pselect`其中一个函数，**传入多个文件描述符**，如果有一个文件描述符**就绪，则返回**，否则阻塞直到超时。

比如`poll()`函数是这样子的：`int poll(struct pollfd *fds,nfds_t nfds, int timeout);`

其中 `pollfd` 结构定义如下：

```c
struct pollfd {
    int fd;         /* 文件描述符 */
    short events;         /* 等待的事件 */
    short revents;       /* 实际发生了的事件 */
};
```



![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nio/moxing-aec90e84-33c5-4f5b-997e-8db54d6bce88.jpg)





![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nio/moxing-62def8ad-3ca3-467b-81f6-5d0a31dd7fdc.jpg)



*   （1）当用户进程调用了select，那么整个进程会被block；
*   （2）而同时，kernel会“监视”所有select负责的socket；
*   （3）当任何一个socket中的数据准备好了，select就会返回；
*   （4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程(空间)。
*   所以，I/O 多路复用的特点是**通过一种机制一个进程能同时等待多个文件描述符**，而这些文件描述符**其中的任意一个进入读就绪状态**，select()函数**就可以返回**。

select/epoll的优势并不是对于单个连接能处理得更快，而是**在于能处理更多的连接**。

## I/O模型总结

正经的描述都在上面给出了，不知道大家理解了没有。下面我举几个例子总结一下这三种模型：

**阻塞I/O：**

*   Java3y跟女朋友去买喜茶，排了很久的队终于可以点饮料了。我要绿研，谢谢。可是喜茶不是点了单就能立即拿，于是我**在喜茶门口等了一小时才拿到**绿研。

*   在门口干等一小时



**非阻塞I/O：**

*   Java3y跟女朋友去买一点点，排了很久的队终于可以点饮料了。我要波霸奶茶，谢谢。可是一点点不是点了单就能立即拿，**同时**服务员告诉我：你大概要等半小时哦。你们先去逛逛吧~于是Java3y跟女朋友去玩了几把斗地主，感觉时间差不多了。于是**又去一点点问**：请问到我了吗？我的单号是xxx。服务员告诉Java3y：还没到呢，现在的单号是XXX，你还要等一会，可以去附近耍耍。问了好几次后，终于拿到我的波霸奶茶了。

*   去逛了下街、斗了下地主，时不时问问到我了没有



**I/O复用模型：**

*   Java3y跟女朋友去麦当劳吃汉堡包，现在就厉害了可以使用微信小程序点餐了。于是跟女朋友找了个地方坐下就用小程序点餐了。点餐了之后玩玩斗地主、聊聊天什么的。**时不时听到广播在复述XXX请取餐**，反正我的单号还没到，就继续玩呗。~~**等听到广播的时候再取餐就是了**。时间过得挺快的，此时传来：Java3y请过来取餐。于是我就能拿到我的麦辣鸡翅汉堡了。

*   听广播取餐，**广播不是为我一个人服务**。广播喊到我了，我过去取就Ok了。

>参考链接：[https://www.zhihu.com/question/29005375/answer/667616386](https://www.zhihu.com/question/29005375/answer/667616386)，整理：沉默王二

---------

最近整理了一份牛逼的学习资料，包括但不限于Java基础部分（JVM、Java集合框架、多线程），还囊括了 **数据库、计算机网络、算法与数据结构、设计模式、框架类Spring、Netty、微服务（Dubbo，消息队列） 网关** 等等等等……详情戳：[可以说是2022年全网最全的学习和找工作的PDF资源了](https://tobebetterjavaer.com/pdf/programmer-111.html)

微信搜 **沉默王二** 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 **111** 即可免费领取。


![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png)